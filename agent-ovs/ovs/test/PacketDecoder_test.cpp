/*
 * Test suite for class PacketDecoder
 *
 * Copyright (c) 2019 Cisco Systems, Inc. and others.  All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this distribution,
 * and is available at http://www.eclipse.org/legal/epl-v10.html
 */
#include <boost/test/unit_test.hpp>
#include "MockPacketLogHandler.h"
#include <opflexagent/IdGenerator.h>
#include "EndpointTenantMapper.h"
BOOST_AUTO_TEST_SUITE(PacketDecoder_test)

using namespace std;
using namespace opflexagent;

/*Dummy io_service objects for constructor*/
static boost::asio::io_service io_1,io_2,io_3;
class PacketDecoderFixture {
public:
    PacketDecoderFixture(): endpointTenantMapper(NULL, NULL, io_3), pktLogger(io_1,io_2,idGen,endpointTenantMapper){
     pktLogger.startListener();
     endpointTenantMapper.shouldPrintTenant = false;
    };
    EndpointTenantMapper endpointTenantMapper;
    MockPacketLogHandler pktLogger;
    opflexagent::IdGenerator idGen;
};

static const uint8_t arp_buf[] = {
0x06, 0x00, 0x65, 0x58, 0x00, 0x00, 0x01, 0x00, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0x0c, 0x01, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0x0d, 0x01, 0x00, 0x00, 0x00, 0x01,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9e, 0x72, 0xa6, 0x94, 0x18, 0xaf, 0x08, 0x06, 0x01, 0x01,
0x08, 0x00, 0x06, 0x04, 0x00, 0x01, 0x9e, 0x72, 0xa6, 0x94, 0x18, 0xaf, 0x0d, 0x00, 0x00, 0x03,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x05};

static const uint8_t icmp_buf[] = {
0x06, 0x00, 0x65, 0x58, 0x00, 0x00, 0x02, 0x00, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0x0c, 0x01, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0x0d, 0x01, 0x00, 0x00, 0x00, 0x00,
0x5a, 0x08, 0x66, 0xce, 0x0b, 0x49, 0x9e, 0x72, 0xa6, 0x94, 0x18, 0xaf, 0x08, 0x00, 0x45, 0x00,
0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0xff, 0x01, 0x2e, 0x61, 0x0e, 0x00, 0x00, 0x02, 0x64, 0x00,
0x00, 0x01, 0x08, 0x00, 0xe9, 0x57, 0x00, 0x00, 0x00, 0x00};

static const uint8_t tcp_buf[] = {
0x06, 0x00, 0x65, 0x58, 0x00, 0x00, 0x01, 0x00, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0x0c, 0x01, 0x00, 0x00, 0x00, 0x02, 0xff, 0xff, 0x0d, 0x01, 0x00, 0x00, 0x00, 0x02,
0x5a, 0x08, 0x66, 0xce, 0x0b, 0x49, 0x9e, 0x72, 0xa6, 0x94, 0x18, 0xaf, 0x08, 0x00, 0x45, 0x00,
0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0xff, 0x06, 0x2e, 0x61, 0x0e, 0x00, 0x00, 0x02, 0x64, 0x00,
0x00, 0x01, 0xa2, 0xa2, 0x00, 0xb3, 0xaf, 0x3b, 0x93, 0x8f, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x02,
0x72, 0x10, 0xc9, 0x41, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4, 0x04, 0x02, 0x08, 0x0a, 0x07, 0x72,
0x09, 0x15, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x09};

static const uint8_t udp_buf[] = {0x04, 0x00, 0x65, 0x58, 0x00, 0x00, 0x02,
0x00, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0c, 0x01,
0x00, 0x00, 0x00, 0x03, 0x5a, 0x08, 0x66, 0xce, 0x0b, 0x49, 0x9e, 0x72, 0xa6,
0x94, 0x18, 0xaf, 0x08, 0x00, 0x45, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00,
0xff, 0x11, 0x2e, 0x61, 0x0e, 0x00, 0x00, 0x02, 0x64, 0x00, 0x00, 0x01, 0xeb,
0xd8, 0x00, 0xa1, 0x00, 0x4a, 0xbc, 0x86};

static const uint8_t udpv6_buf[] = {0x04, 0x00, 0x65, 0x58, 0x00, 0x00, 0x01,
0x00, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0c, 0x01,
0x00, 0x00, 0x00, 0x04, 0x5a, 0x08, 0x66, 0xce, 0x0b, 0x49, 0x9e, 0x72, 0xa6,
0x94, 0x18, 0xaf, 0x86, 0xdd, 0x60, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x11, 0x01,
0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x27, 0xff, 0xfe,
0xfe, 0x8f, 0x95, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x02, 0x22, 0x02, 0x23, 0x00, 0x3c, 0xad,
0x08};

static const uint8_t tcpv6_buf[] = {0x04, 0x00, 0x65, 0x58, 0x00, 0x00, 0x01,
0x00, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0c, 0x01,
0x00, 0x00, 0x00, 0x05, 0x5a, 0x08, 0x66, 0xce, 0x0b, 0x49, 0x9e, 0x72, 0xa6,
0x94, 0x18, 0xaf, 0x86, 0xdd, 0x60, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x06, 0x01,
0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x27, 0xff, 0xfe,
0xfe, 0x8f, 0x95, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0xa2, 0xa2, 0x00, 0xb3, 0xaf, 0x3b, 0x93,
0x8f, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x02, 0x72, 0x10, 0xc9, 0x41, 0x00, 0x00,
0x02, 0x04, 0x05, 0xb4, 0x04, 0x02, 0x08, 0x0a, 0x07, 0x72, 0x09, 0x15, 0x00,
0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x09 };

static const uint8_t igmp_buf[] = {
0x1d, 0x00, 0x65, 0x58, 0x00, 0x00, 0x01, 0x00,
0xff, 0xff, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0x09, 0x01, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0x0b, 0x04, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0c, 0x01,
0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x5e, 0x00,
0x00, 0x16, 0xfa, 0x16, 0x3e, 0xd3, 0xf3, 0x0b,
0x81, 0x00, 0x0f, 0xfe, 0x08, 0x00, 0x46, 0xc0,
0x00, 0x28, 0x00, 0x00, 0x40, 0x00, 0x01, 0x02,
0x71, 0x48, 0xc0, 0xa8, 0xd2, 0x08, 0xe0, 0x00,
0x00, 0x16, 0x94, 0x04, 0x00, 0x00, 0x22, 0x00,
0xf9, 0x02, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00,
0x00, 0x00, 0xe0, 0x00, 0x00, 0xfb
};


static const uint8_t arp_stream[] = { 
0x22, 0x00, 0x65, 0x58, 0x00, 0x00, 0x01, 0x00, 
0xff, 0xff, 0x00, 0x01, 0x00, 0x00, 0x12, 0x34, 
0xff, 0xff, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0x02, 0x01, 0x00, 0x00, 0x30, 0x00, 
0xff, 0xff, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0x04, 0x01, 0x00, 0x00, 0x00, 0x01, 
0xff, 0xff, 0x05, 0x01, 0x00, 0x00, 0x00, 0x01, 
0xff, 0xff, 0x06, 0x01, 0x00, 0x00, 0x00, 0x01, 
0xff, 0xff, 0x07, 0x01, 0x00, 0x00, 0x00, 0x03, 
0xff, 0xff, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0x09, 0x01, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0x0b, 0x04, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0c, 0x01, 
0x00, 0x00, 0x00, 0x0c, 0xff, 0xff, 0x0d, 0x01, 
0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0x0e, 0x02, 
0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0x08, 0x06, 0x00, 0x01, 
0x08, 0x00, 0x06, 0x04, 0x00, 0x01, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0x0a, 0x00, 0x02, 0x02, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 
0x02, 0x03
};

static const uint8_t lldp_buf[] = {
0x06, 0x00, 0x65, 0x58, 0x00, 0x00, 0x01, 0x00, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0x0c, 0x01, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0x0d, 0x01, 0x00, 0x00, 0x00, 0x01,
0x01, 0x80, 0xc2, 0x00, 0x00, 0x0e, 0x9e, 0x72, 0xa6, 0x94, 0x18, 0xaf, 0x08, 0x06, 0x01, 0x01,
0x08, 0x00, 0x06, 0x04, 0x00, 0x01, 0x9e, 0x72, 0xa6, 0x94, 0x18, 0xaf, 0x0d, 0x00, 0x00, 0x03,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x05};

static const uint8_t mld_buf[] = {0x04, 0x00, 0x65, 0x58, 0x00, 0x00, 0x01,
0x00, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0c, 0x01,
0x00, 0x00, 0x00, 0x05, 0x33, 0x33, 0x00, 0xce, 0x0b, 0x49, 0x9e, 0x72, 0xa6,
0x94, 0x18, 0xaf, 0x86, 0xdd, 0x60, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x3a, 0x01,
0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x27, 0xff, 0xfe,
0xfe, 0x8f, 0x95, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0xa2, 0xa2, 0x00, 0xb3, 0xaf, 0x3b, 0x93,
0x8f, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x02, 0x72, 0x10, 0xc9, 0x41, 0x00, 0x00,
0x02, 0x04, 0x05, 0xb4, 0x04, 0x02, 0x08, 0x0a, 0x07, 0x72, 0x09, 0x15, 0x00,
0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x09 };

static const uint8_t mdns_v4_buf[] = {0x04, 0x00, 0x65, 0x58, 0x00, 0x00, 0x02,
0x00, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0c, 0x01,
0x00, 0x00, 0x00, 0x03, 0x01, 0x0e, 0x00, 0x00, 0x00, 0xfb, 0x9e, 0x72, 0xa6,
0x94, 0x18, 0xaf, 0x08, 0x00, 0x45, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00,
0xff, 0x11, 0x2e, 0x61, 0x0e, 0x00, 0x00, 0x02, 0xe0, 0x00, 0x00, 0xfb, 0x14,
0xe9, 0x14, 0xe9, 0x00, 0x4a, 0xbc, 0x86};

static const uint8_t mdns_v6_buf[] = {0x04, 0x00, 0x65, 0x58, 0x00, 0x00, 0x01,
0x00, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0c, 0x01,
0x00, 0x00, 0x00, 0x04, 0x33, 0x33, 0x00, 0x00, 0xfb, 0x49, 0x9e, 0x72, 0xa6,
0x94, 0x18, 0xaf, 0x86, 0xdd, 0x60, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x11, 0x01,
0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x27, 0xff, 0xfe,
0xfe, 0x8f, 0x95, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0xfb, 0x14, 0xe9, 0x14, 0xe9, 0x00, 0x3c, 0xad,
0x08};

BOOST_FIXTURE_TEST_CASE(arp_test, PacketDecoderFixture) {
    auto pktDecoder = pktLogger.getDecoder();
    ParseInfo p(&pktDecoder);
    PacketTuple expectedTuple("", "Int-PORT_SECURITY_TABLE DENY", "9e:72:a6:94:18:af", "ff:ff:ff:ff:ff:ff", "ARP", "13.0.0.3", "13.0.0.5" ,"", "", "");
    std::string expected(" SMAC=9e:72:a6:94:18:af DMAC=ff:ff:ff:ff:ff:ff ETYP=ARP ARP_SPA=13.0.0.3 ARP_TPA=13.0.0.5 ARP_OP=1");
    int ret = pktDecoder.decode(arp_buf, 74, p);
    BOOST_CHECK(ret == 0);
    std::string dropReason;
    pktLogger.getDropReason(p, dropReason);
    p.packetTuple.setField(0, dropReason);
    BOOST_CHECK(p.parsedString == expected);
    BOOST_CHECK(p.packetTuple == expectedTuple);
}

BOOST_FIXTURE_TEST_CASE(icmp_test, PacketDecoderFixture) {
    auto pktDecoder = pktLogger.getDecoder();
    ParseInfo p(&pktDecoder);
    PacketTuple expectedTuple("", "Acc-GROUP_MAP_TABLE MISS", "9e:72:a6:94:18:af", "5a:08:66:ce:0b:49", "IPv4", "14.0.0.2", "100.0.0.1" ,"ICMP", "", "");
    std::string expected(" SMAC=9e:72:a6:94:18:af DMAC=5a:08:66:ce:0b:49 ETYP=IPv4 SRC=14.0.0.2 DST=100.0.0.1 LEN=28 DSCP=0 TTL=255 ID=0 FLAGS=0 FRAG=0 PROTO=ICMP TYPE=8 CODE=0 ID=0 SEQ=0");
    int ret = pktDecoder.decode(icmp_buf, 74, p);
    BOOST_CHECK(ret == 0);
    std::string dropReason;
    pktLogger.getDropReason(p, dropReason);
    p.packetTuple.setField(0, dropReason);
    BOOST_CHECK(p.parsedString == expected);
    BOOST_CHECK(p.packetTuple == expectedTuple);
}

BOOST_FIXTURE_TEST_CASE(tcp_test, PacketDecoderFixture) {
    auto pktDecoder = pktLogger.getDecoder();
    ParseInfo p(&pktDecoder);
    PacketTuple expectedTuple("", "Int-SOURCE_TABLE PERMIT", "9e:72:a6:94:18:af", "5a:08:66:ce:0b:49", "IPv4", "14.0.0.2", "100.0.0.1" ,"TCP", "41634", "179");
    std::string expected(" SMAC=9e:72:a6:94:18:af DMAC=5a:08:66:ce:0b:49 ETYP=IPv4 SRC=14.0.0.2 DST=100.0.0.1 LEN=28 DSCP=0 TTL=255 ID=0 FLAGS=0 FRAG=0 PROTO=TCP SPT=41634 DPT=179 SEQ=2939917199 ACK=0 LEN=10 WINDOWS=29200 SYN  URGP=0");
    int ret = pktDecoder.decode(tcp_buf, 106, p);
    BOOST_CHECK(ret == 0);
    std::string dropReason;
    pktLogger.getDropReason(p, dropReason);
    p.packetTuple.setField(0, dropReason);
    BOOST_CHECK(p.parsedString == expected);
    BOOST_CHECK(p.packetTuple == expectedTuple);
}

BOOST_FIXTURE_TEST_CASE(udp_test, PacketDecoderFixture) {
    auto pktDecoder = pktLogger.getDecoder();
    ParseInfo p(&pktDecoder);
    PacketTuple expectedTuple("", "Acc-SEC_GROUP_OUT_TABLE MISS", "9e:72:a6:94:18:af", "5a:08:66:ce:0b:49", "IPv4", "14.0.0.2", "100.0.0.1" ,"UDP", "60376", "161");
    std::string expected(" SMAC=9e:72:a6:94:18:af DMAC=5a:08:66:ce:0b:49 ETYP=IPv4 SRC=14.0.0.2 DST=100.0.0.1 LEN=28 DSCP=0 TTL=255 ID=0 FLAGS=0 FRAG=0 PROTO=UDP SPT=60376 DPT=161 LEN=74");
    int ret = pktDecoder.decode(udp_buf, 66, p);
    BOOST_CHECK(ret == 0);
    std::string dropReason;
    pktLogger.getDropReason(p, dropReason);
    p.packetTuple.setField(0, dropReason);
    BOOST_CHECK(p.parsedString == expected);
    BOOST_CHECK(p.packetTuple == expectedTuple);
}

BOOST_FIXTURE_TEST_CASE(udp_over_v6_test, PacketDecoderFixture) {
    auto pktDecoder = pktLogger.getDecoder();
    ParseInfo p(&pktDecoder);
    PacketTuple expectedTuple("", "Int-SERVICE_REV_TABLE MISS", "9e:72:a6:94:18:af", "5a:08:66:ce:0b:49", "IPv6", "fe80::a00:27ff:fefe:8f95", "ff02::1:2" ,"UDP", "546", "547");
    std::string expected(" SMAC=9e:72:a6:94:18:af DMAC=5a:08:66:ce:0b:49 ETYP=IPv6 SRC=fe80::a00:27ff:fefe:8f95 DST=ff02::1:2 LEN=60 TC=0 HL=1 FL=0 PROTO=UDP SPT=546 DPT=547 LEN=60");
    int ret = pktDecoder.decode(udpv6_buf, 86, p);
    BOOST_CHECK(ret == 0);
    std::string dropReason;
    pktLogger.getDropReason(p, dropReason);
    p.packetTuple.setField(0, dropReason);
    BOOST_CHECK(p.parsedString == expected);
    BOOST_CHECK(p.packetTuple == expectedTuple);
}

BOOST_FIXTURE_TEST_CASE(tcp_over_v6_test, PacketDecoderFixture) {
    auto pktDecoder = pktLogger.getDecoder();
    ParseInfo p(&pktDecoder);
    PacketTuple expectedTuple("", "Int-BRIDGE_TABLE MISS", "9e:72:a6:94:18:af", "5a:08:66:ce:0b:49", "IPv6", "fe80::a00:27ff:fefe:8f95", "ff02::1:2" ,"TCP", "41634", "179");
    std::string expected(" SMAC=9e:72:a6:94:18:af DMAC=5a:08:66:ce:0b:49 ETYP=IPv6 SRC=fe80::a00:27ff:fefe:8f95 DST=ff02::1:2 LEN=60 TC=0 HL=1 FL=0 PROTO=TCP SPT=41634 DPT=179 SEQ=2939917199 ACK=0 LEN=10 WINDOWS=29200 SYN  URGP=0");
    int ret = pktDecoder.decode(tcpv6_buf, 118, p);
    BOOST_CHECK(ret == 0);
    std::string dropReason;
    pktLogger.getDropReason(p, dropReason);
    p.packetTuple.setField(0, dropReason);
    BOOST_CHECK(p.parsedString == expected);
    BOOST_CHECK(p.packetTuple == expectedTuple);
}

BOOST_FIXTURE_TEST_CASE(ip_options_unrecognized_test, PacketDecoderFixture) {
    auto pktDecoder = pktLogger.getDecoder();
    ParseInfo p(&pktDecoder);
    PacketTuple expectedTuple("", "Int-PORT_SECURITY_TABLE MISS", "fa:16:3e:d3:f3:0b", "01:00:5e:00:00:16", "IPv4", "192.168.210.8", "224.0.0.22" ,"2_unrecognized", "", "");
    std::string expected(" SMAC=fa:16:3e:d3:f3:0b DMAC=01:00:5e:00:00:16 ETYP=Qtag QTAG=4094 IPv4 SRC=192.168.210.8 DST=224.0.0.22 LEN=40 DSCP=48 TTL=1 ID=0 FLAGS=2 FRAG=0 PROTO=2_unrecognized");
    int ret = pktDecoder.decode(igmp_buf, 178, p);
    BOOST_CHECK(ret == 0);
    std::string dropReason;
    pktLogger.getDropReason(p, dropReason);
    p.packetTuple.setField(0, dropReason);
    BOOST_CHECK(p.parsedString == expected);
    BOOST_CHECK(p.packetTuple == expectedTuple);
}

BOOST_FIXTURE_TEST_CASE(enhanceDropReason_test, PacketDecoderFixture) {
    endpointTenantMapper.shouldPrintTenant = true;
    string dir(".");
    string nmspc("l24classifierRule");
    string u1("/PolicyUniverse/PolicySpace/test/GbpeL24Classifier/classifier7/");
    uint32_t u1_id;
    idGen.setPersistLocation(dir);
    idGen.initNamespace(nmspc);
    u1_id = idGen.getId(nmspc, u1);
    BOOST_CHECK(u1_id != 0);
    BOOST_CHECK(u1_id == idGen.getId(nmspc, u1));
    std::string expected("Int-POL_TABLE DENY /PolicyUniverse/PolicySpace/test/GbpeL24Classifier/classifier7/ STID=N/A DTID=N/A");
    auto pktDecoder = pktLogger.getDecoder();
    ParseInfo p(&pktDecoder);
    int ret = pktDecoder.decode(arp_stream, 186, p);
    BOOST_CHECK(ret == 0);
    std::string dropReason;
    pktLogger.getDropReason(p, dropReason);
    BOOST_CHECK(dropReason == expected);
}

BOOST_FIXTURE_TEST_CASE(printSourceTenant_test, PacketDecoderFixture) {
    endpointTenantMapper.shouldPrintTenant = true;
    string dir(".");
    string nmspc("l24classifierRule");
    string u1("/PolicyUniverse/PolicySpace/test/GbpeL24Classifier/classifier7/");
    uint32_t u1_id;
    endpointTenantMapper.UpdateVNIDMapping(4660, "tenantA");
    endpointTenantMapper.UpdateVNIDMapping(12288, "tenantB");
    idGen.setPersistLocation(dir);
    idGen.initNamespace(nmspc);
    u1_id = idGen.getId(nmspc, u1);
    BOOST_CHECK(u1_id != 0);
    BOOST_CHECK(u1_id == idGen.getId(nmspc, u1));
    std::string expected("Int-POL_TABLE DENY /PolicyUniverse/PolicySpace/test/GbpeL24Classifier/classifier7/ STID=tenantA DTID=tenantB");
    auto pktDecoder = pktLogger.getDecoder();
    ParseInfo p(&pktDecoder);
    int ret = pktDecoder.decode(arp_stream, 186, p);
    BOOST_CHECK(ret == 0);
    std::string dropReason;
    pktLogger.getDropReason(p, dropReason);
    BOOST_CHECK(dropReason == expected);
}

BOOST_FIXTURE_TEST_CASE(prune_tests, PacketDecoderFixture) {
    auto pktDecoder = pktLogger.getDecoder();
    ParseInfo p1(&pktDecoder);
    int ret = pktDecoder.decode(igmp_buf, 178, p1);
    BOOST_CHECK(ret == 0);
    pktLogger.pruneLog(p1);
    BOOST_CHECK(p1.pruneLog == true);
    ParseInfo p2(&pktDecoder);
    ret = pktDecoder.decode(lldp_buf, 74, p2);
    BOOST_CHECK(ret == 0);
    pktLogger.pruneLog(p2);
    BOOST_CHECK(p2.pruneLog == true);
    ParseInfo p3(&pktDecoder);
    ret = pktDecoder.decode(mld_buf, 118, p3);
    BOOST_CHECK(ret == 0);
    pktLogger.pruneLog(p3);
    BOOST_CHECK(p3.pruneLog == true);
    ParseInfo p4(&pktDecoder);
    ret = pktDecoder.decode(mdns_v4_buf, 66, p4);
    BOOST_CHECK(ret == 0);
    pktLogger.pruneLog(p4);
    BOOST_CHECK(p4.pruneLog == true);
    ParseInfo p5(&pktDecoder);
    ret = pktDecoder.decode(mdns_v6_buf, 86, p5);
    BOOST_CHECK(ret == 0);
    pktLogger.pruneLog(p5);
    BOOST_CHECK(p5.pruneLog == true);
}

BOOST_FIXTURE_TEST_CASE(user_prune_tests, PacketDecoderFixture) {
    auto pktDecoder = pktLogger.getDecoder();
    ParseInfo p1(&pktDecoder);
    std::shared_ptr<PacketFilterSpec> filt1(new PacketFilterSpec());
    filt1->setField(TFLD_DST_MAC,"5a:08:66:ce:0b:49");
    filt1->setField(TFLD_SRC_MAC,"9e:72:a6:94:18:af");
    filt1->setField(TFLD_ETH_TYPE,"2048");
    filt1->setField(TFLD_IP_PROTO,"6");
    pktLogger.updatePruneFilter("filt1",filt1);
    int ret = pktDecoder.decode(tcp_buf, 106, p1);
    BOOST_CHECK(ret == 0);
    pktLogger.pruneLog(p1);
    BOOST_CHECK(p1.pruneLog == true);
    ParseInfo p2(&pktDecoder);
    pktLogger.deletePruneFilter("filt1");
    ret = pktDecoder.decode(tcp_buf, 106, p2);
    BOOST_CHECK(ret == 0);
    pktLogger.pruneLog(p2);
    BOOST_CHECK(p2.pruneLog == false);
    ParseInfo p3(&pktDecoder);
    filt1->setField(TFLD_DST_MAC,"5a:08:66:00:00:00");
    filt1->setField(TFLD_DMAC_MASK,"ff:ff:ff:00:00:00");
    filt1->setField(TFLD_SRC_MAC,"9e:72:a6:94:18:00");
    filt1->setField(TFLD_SMAC_MASK,"ff:ff:ff:ff:ff:00");
    filt1->setField(TFLD_SRC_IP,"14.0.0.2");
    filt1->setField(TFLD_DST_IP,"100.0.0.1");
    filt1->setField(TFLD_IP_PROTO,"17");
    pktLogger.updatePruneFilter("filt2",filt1);
    ret = pktDecoder.decode(udp_buf, 66, p3);
    BOOST_CHECK(ret == 0);
    pktLogger.pruneLog(p3);
    BOOST_CHECK(p3.pruneLog == true);
}

BOOST_FIXTURE_TEST_CASE(user_prune_ip_prefix_tests, PacketDecoderFixture) {
    auto pktDecoder = pktLogger.getDecoder();
    std::shared_ptr<PacketFilterSpec> filt1(new PacketFilterSpec());
    ParseInfo p3(&pktDecoder);
    filt1->setField(TFLD_SRC_IP,"14.0.0.0");
    filt1->setField(TFLD_SPFX_LEN,"24");
    filt1->setField(TFLD_DST_IP,"100.0.0.0");
    filt1->setField(TFLD_DPFX_LEN,"24");
    filt1->setField(TFLD_IP_PROTO,"17");
    pktLogger.updatePruneFilter("filt1",filt1);
    int ret = pktDecoder.decode(udp_buf, 66, p3);
    BOOST_CHECK(ret == 0);
    pktLogger.pruneLog(p3);
    BOOST_CHECK(p3.pruneLog == true);
    pktLogger.deletePruneFilter("filt1");
    filt1.reset(new PacketFilterSpec());
    filt1->setField(TFLD_SRC_IP,"14.0.0.0");
    filt1->setField(TFLD_DST_IP,"100.0.0.0");
    pktLogger.updatePruneFilter("filt2",filt1);
    pktLogger.pruneLog(p3);
    BOOST_CHECK(p3.pruneLog == false);
    ParseInfo p4(&pktDecoder);
    ret = pktDecoder.decode(udpv6_buf, 86, p4);
    BOOST_CHECK(ret == 0);
    pktLogger.pruneLog(p4);
    BOOST_CHECK(p4.pruneLog == false);
    pktLogger.deletePruneFilter("filt1");
    filt1.reset(new PacketFilterSpec());
    filt1->setField(TFLD_SRC_IP,"fe80::a00:27ff:fefe:8f95");
    filt1->setField(TFLD_DST_IP,"ff02::1:2");
    pktLogger.updatePruneFilter("filt3",filt1);
    pktLogger.pruneLog(p4);
    BOOST_CHECK(p4.pruneLog == true);
    pktLogger.deletePruneFilter("filt1");
    filt1.reset(new PacketFilterSpec());
    filt1->setField(TFLD_SRC_IP,"fe80::");
    filt1->setField(TFLD_SPFX_LEN,"64");
    filt1->setField(TFLD_DST_IP,"ff02::1:0");
    filt1->setField(TFLD_DPFX_LEN,"120");
    pktLogger.updatePruneFilter("filt4",filt1);
    pktLogger.pruneLog(p4);
    BOOST_CHECK(p4.pruneLog == true);
}

BOOST_AUTO_TEST_SUITE_END()
